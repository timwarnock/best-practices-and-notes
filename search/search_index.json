{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tim's Best Practices and Notes \u00b6 Useful things I've learned, e.g., Conventional Commits","title":"Tim's Best Practices and Notes"},{"location":"#tims-best-practices-and-notes","text":"Useful things I've learned, e.g., Conventional Commits","title":"Tim's Best Practices and Notes"},{"location":"agile/","text":"Time for Agile to Die \u00b6 \"Agile often puts processes over people, and it\u2019s pushing women engineers into non-technical roles.\" Interview with Mary Poppendieck , https://builtin.com/software-engineering-perspectives/lean-agile-methodology-software-engineering http://www.leanessays.com/2019/07/grown-up-lean.html http://www.leanessays.com/2017/11/the-cost-center-trap.html \"At the time, software development was suffering from a mistaken belief: that building things fast and building things well were fundamentally opposed.\" \"Yes, customers want functions and features, Mary said, but more than that, they want solutions to their problems.\" \"Agile was very good at delivering features, but it didn\u2019t make any difference. Companies were no better off when they had features faster than when they had features slower. The focus needs to be not on features, not on output, but on outcomes and the impact of what employees are doing.\" Today, however, many don\u2019t view software development as an engineering endeavor \u2014 or, more likely, are unable to because of obstacles in their organizations, Mary said. Engineering is about seeing a problem, understanding it and using the technology you're good at to solve it as quickly as possible. Software, she said, has become about \"projects, briefings and being nice to people.\" \"Way too much of agile has been not about technology, but about people and about managing things and about getting stuff done \u2014 not necessarily getting the right stuff done, but getting stuff done \u2014 rather than what engineering is about,\" she said. \"Agile has come to mean anything but the fundamental, underlying technical capability necessary to do really good software engineering.\" \"They want a process to make sure that software is done right, instead of considering that maybe their fundamental concept of what software is is wrong,\" she said. \"Find me an actual tech company that talks much about agile, and I will be astounded.\" \u201cIf you look at agile, where do women end up? They end up being scrum masters and that kind of thing. That\u2019s not an engineering job. That\u2019s putting women \u2018in a woman\u2019s place,\u2019 rather than putting women in an engineering job. And I think that\u2019s really bad,\u201d she said. \"According to Mary, if agile methodology creates more non-technical roles and steals focus from technical problem-solving, its continued popularity could work against women developers.\"","title":"End of Agile"},{"location":"agile/#time-for-agile-to-die","text":"\"Agile often puts processes over people, and it\u2019s pushing women engineers into non-technical roles.\" Interview with Mary Poppendieck , https://builtin.com/software-engineering-perspectives/lean-agile-methodology-software-engineering http://www.leanessays.com/2019/07/grown-up-lean.html http://www.leanessays.com/2017/11/the-cost-center-trap.html \"At the time, software development was suffering from a mistaken belief: that building things fast and building things well were fundamentally opposed.\" \"Yes, customers want functions and features, Mary said, but more than that, they want solutions to their problems.\" \"Agile was very good at delivering features, but it didn\u2019t make any difference. Companies were no better off when they had features faster than when they had features slower. The focus needs to be not on features, not on output, but on outcomes and the impact of what employees are doing.\" Today, however, many don\u2019t view software development as an engineering endeavor \u2014 or, more likely, are unable to because of obstacles in their organizations, Mary said. Engineering is about seeing a problem, understanding it and using the technology you're good at to solve it as quickly as possible. Software, she said, has become about \"projects, briefings and being nice to people.\" \"Way too much of agile has been not about technology, but about people and about managing things and about getting stuff done \u2014 not necessarily getting the right stuff done, but getting stuff done \u2014 rather than what engineering is about,\" she said. \"Agile has come to mean anything but the fundamental, underlying technical capability necessary to do really good software engineering.\" \"They want a process to make sure that software is done right, instead of considering that maybe their fundamental concept of what software is is wrong,\" she said. \"Find me an actual tech company that talks much about agile, and I will be astounded.\" \u201cIf you look at agile, where do women end up? They end up being scrum masters and that kind of thing. That\u2019s not an engineering job. That\u2019s putting women \u2018in a woman\u2019s place,\u2019 rather than putting women in an engineering job. And I think that\u2019s really bad,\u201d she said. \"According to Mary, if agile methodology creates more non-technical roles and steals focus from technical problem-solving, its continued popularity could work against women developers.\"","title":"Time for Agile to Die"},{"location":"conventional-commits/","text":"Conventional Commits \u00b6 Because I keep forgetting to use these, here is a sensible commit message convention I should be using. By using this convention, commit log messages will read like a changelog. type(optional scope): present-tense description Common Types \u00b6 feat : new feature for the user, not a new feature for build script fix : bug fix for the user, not a fix to a build script docs : change to the documentation style : formatting, missing semi colons, etc; no production code change refactor : refactoring production code, eg. renaming a variable test : adding missing tests, refactoring tests; no production code change chore : update build scripts, etc; no production code change Examples \u00b6 feat: add FOO search algorithm fix(search): change case, Foo not FOO test(search): add additional Foo tests chore(search): add CI deployment targets feat: add MAB search algorithm chooser refactor: BREAKING CHANGE: remove MAB and set Foo search algorithm as default docs(search): add README for Foo search References \u00b6 https://www.conventionalcommits.org/ https://seesparkbox.com/foundry/semantic_commit_messages","title":"Conventional Commits"},{"location":"conventional-commits/#conventional-commits","text":"Because I keep forgetting to use these, here is a sensible commit message convention I should be using. By using this convention, commit log messages will read like a changelog. type(optional scope): present-tense description","title":"Conventional Commits"},{"location":"conventional-commits/#common-types","text":"feat : new feature for the user, not a new feature for build script fix : bug fix for the user, not a fix to a build script docs : change to the documentation style : formatting, missing semi colons, etc; no production code change refactor : refactoring production code, eg. renaming a variable test : adding missing tests, refactoring tests; no production code change chore : update build scripts, etc; no production code change","title":"Common Types"},{"location":"conventional-commits/#examples","text":"feat: add FOO search algorithm fix(search): change case, Foo not FOO test(search): add additional Foo tests chore(search): add CI deployment targets feat: add MAB search algorithm chooser refactor: BREAKING CHANGE: remove MAB and set Foo search algorithm as default docs(search): add README for Foo search","title":"Examples"},{"location":"conventional-commits/#references","text":"https://www.conventionalcommits.org/ https://seesparkbox.com/foundry/semantic_commit_messages","title":"References"},{"location":"good-architecture/","text":"Good Architecture \u00b6 What are the characteristics of Good Architecture? Opinions vary, but what can the data tell us? Focus on Engineers \u00b6 Architects must focus on Engineers and not tools or technologies. Choose tools and technologies that empower the engineers to produce the right outcomes. What are the right outcomes? Solutions to customer's problems. Nothing more. Loosely Coupled \u00b6 Empowered teams are responsibile to create the right solutions which are loosely coupled from one another. This is the most important part of software architecture. Ref \u00b6 Deutsch Limit Steve Yegge's Platform Rant Conway's Law Inverse Conway Maneuver","title":"Good Architecture"},{"location":"good-architecture/#good-architecture","text":"What are the characteristics of Good Architecture? Opinions vary, but what can the data tell us?","title":"Good Architecture"},{"location":"good-architecture/#focus-on-engineers","text":"Architects must focus on Engineers and not tools or technologies. Choose tools and technologies that empower the engineers to produce the right outcomes. What are the right outcomes? Solutions to customer's problems. Nothing more.","title":"Focus on Engineers"},{"location":"good-architecture/#loosely-coupled","text":"Empowered teams are responsibile to create the right solutions which are loosely coupled from one another. This is the most important part of software architecture.","title":"Loosely Coupled"},{"location":"good-architecture/#ref","text":"Deutsch Limit Steve Yegge's Platform Rant Conway's Law Inverse Conway Maneuver","title":"Ref"},{"location":"good-code/","text":"Good Code? \u00b6 Agile Manifesto Rugged Manifesto What is (and what is not) good code? Specifically, what are the most meaningful measures of good code? How can one prove that code is good or bad? Obviously, good code should be high performing secure fault-tolerant scalable And while it's easy to list nice attributes of good code, from test coverage to a clean and readable style, good code always starts off as bad code. No one writes good code from scratch. We edit and massage bad code until it becomes better; we continuously test, and we demo our working software to our users, refining the code until it slowly approaches what might be considered good. But okay, is there any way to measure this objectively? high performance \u00b6 An application should survive heavy load tests with reasonable performance characteristics. E.g., a well-designed HTTP \"microservice\" (yes, those are ironic quotes) should handle at-least 10,000 tps (transactions-per-second) on a single instance, and scale to 100,000 or even a million transactions-per-second without any significant degredation. gatling.io artillery.io secure \u00b6 An application should be secure from obvious security exploits. OWASP Top 10 github.com/zaproxy/zaproxy nmap kali... fault tolerant \u00b6 An application should provide a reasonable level of fault tolerance. Unit+Integration Tests with an appropriate level of coverage, augmented by, Mutation Testing: PIT, stryker, stryker4s https://stryker-mutator.io/stryker4s/ scalable \u00b6 An application should scale to any desireable load, distributed across any geographic segment. Kubernetes, Mesos, Swarm","title":"Good Code"},{"location":"good-code/#good-code","text":"Agile Manifesto Rugged Manifesto What is (and what is not) good code? Specifically, what are the most meaningful measures of good code? How can one prove that code is good or bad? Obviously, good code should be high performing secure fault-tolerant scalable And while it's easy to list nice attributes of good code, from test coverage to a clean and readable style, good code always starts off as bad code. No one writes good code from scratch. We edit and massage bad code until it becomes better; we continuously test, and we demo our working software to our users, refining the code until it slowly approaches what might be considered good. But okay, is there any way to measure this objectively?","title":"Good Code?"},{"location":"good-code/#high-performance","text":"An application should survive heavy load tests with reasonable performance characteristics. E.g., a well-designed HTTP \"microservice\" (yes, those are ironic quotes) should handle at-least 10,000 tps (transactions-per-second) on a single instance, and scale to 100,000 or even a million transactions-per-second without any significant degredation. gatling.io artillery.io","title":"high performance"},{"location":"good-code/#secure","text":"An application should be secure from obvious security exploits. OWASP Top 10 github.com/zaproxy/zaproxy nmap kali...","title":"secure"},{"location":"good-code/#fault-tolerant","text":"An application should provide a reasonable level of fault tolerance. Unit+Integration Tests with an appropriate level of coverage, augmented by, Mutation Testing: PIT, stryker, stryker4s https://stryker-mutator.io/stryker4s/","title":"fault tolerant"},{"location":"good-code/#scalable","text":"An application should scale to any desireable load, distributed across any geographic segment. Kubernetes, Mesos, Swarm","title":"scalable"},{"location":"good-teams/","text":"Good Teams \u00b6 What is a Good software engineering team? How would you measure that? Notes from DevOps and Lean Software research. A good team will build quality products (services, platforms, etc) that solve real problems; and in order to be successful, a good team will require an inspiring vision, a Generative Culture, and the responsibility of fast / frequent deployments. The Vision \u00b6 A successful organization must have an inspiring vision; and it must be shared so as to unite the different teams and technologies within the organization. Without an inspiring (and shared) vision, an organization will inevitably fall into a default Bureaucratic Culture (a rule-oriented culture). In that environment software developers will adopt what is known as a mercenary mindset . What's worse, due to Conway's Law , these mercenary-minded developers will create technical output (products, services, platforms, etc) that reflect the bureaucratic communication channels between teams within the organization -- and they will NOT solve the problems of the users. The Measures \u00b6 How would one measure a good team? Or more importantly, what can we easily measure that is a strong predictor for a high-performing software development team? It turns out, the following cluster of easy-to-measure metrics forms the best predictor of a high-performing team in a Generative Culture (a performance-oriented culture). Positive Measures \u00b6 Deployment Frequency -- how often do you deploy to production? Lead-Time -- from code-commit to production Mean-Time-To-Repair (MTTR) Change Failure Rate More usefully, the first three (as a cluster) predict the fourth measure . In other words, the most stable systems (with the lowest failure rates) are the systems that have fast and frequent deployments in a fully-automated CI/CD pipeline. A fully automated CI/CD pipeline is an essential and necesary part of building quality software, but as we'll see, there's much more to consider. Negavitve Measures \u00b6 In other words, what NOT TO DO ? This may defy conventional wisdom, but the following are negative-predictors towards quality software. In other words, they are not only highly correlated with bad software, the mere existence of the following will predict a higher failure rate, as well as increased security risks. Change Approval Board Velocity -- in the Agile/Scrum context Utilization -- \"as utilization approaches 100%, Lead-Time approaches infinity\" Meaningless Measures \u00b6 Surprisingly, the following common measures provide no correlation whatsover between high-performing teams and low-performing teams. These are not negatively correlated (and thus may still be important factors within your organization); but they simply do not correlate to the overall quality and stability of your software, and should not be used as comparative measures. Age of technology (mainframe vs distributed microservices) Size of the organization Whether Ops team or Dev team performs deployments Unit-test coverage Lines of code This isn't to say that the above items are themselves meaningless, far from it, but it's important to understand that these measures will not predict the quality and stability of your software. For example, there are teams ingrating with ancient mainframes (and no unit-tests) that are outperforming teams with a microservice architecture and 100% unit-test coverage. And while the size of an organization will not predict software quality, it is true that high-performing teams tend to scale much easier (scaling an organization requires a loosely coupled architecture more than anything else). The Culture \u00b6 There are three categories of culture that one will find within software engineering organizations. Of these three, the Generative Culture (performance-oriented) is the one most likely produce quality software. For more information see Westrum Model of Organizational Culture Power-oriented Rule-oriented Performance-oriented Low cooperation Modest cooperation High cooperation Messengers \"shot\" Messengers neglected Messengers trained Responsibilities shirked Narrow responsibilities Risks are shared Bridging discouraged Bridging tolerated Bridging encouraged Failure leads to scapegoating Failure leads to justice Failure leads to inquiry Novelty crushed Novelty leads to problems Novelty implemented Power-oriented \u00b6 Also known as Pathological Culture , a Power-oriented Culture values individual goals over organizational goals, where the loudest and most powerful voice in the room gets their way. Communication does not flow easily, and problems are typically suppressed. Software created in a Power-oriented Culture will tend to have a Tightly Coupled architecture (due to Conway's Law ) and will reflect the particular whims of whoever has the most powerful voice (typically whoever is at the top of the hierarchy). Rule-oriented \u00b6 Also known as Bureaucratic Culture , a Rule-oriented Culture values departmental goals over organizational goals. This is the most common culture in software engineering organizations, and it is the default culture for most large organizations. While often friendly, information flow is stymied by bureaucratic approvals, and problems are typically ignored. Often times the emphasis is on being nice and well-liked, rather than building quality software (and making users happy). Software created in a Rule-oriented Culture will tend to have a Tightly Coupled architecture (due to Conway's Law ) and will reflect the particular bureaucratic communication channels between teams. There is likely a Change Approval Board, with deployments that are slower (measured in hours) and less-frequent (weekly or more) than what a fully automated CI/CD pipeline could otherwise provide. Performance-oriented \u00b6 Also known as Generative Culture , a Performance-oriented Culture values the mission of the organization over all else. It is in this environment where developers adopt a missionary mindset (rather than the more common mercenary mindset). Information flows easily, problems and failures are discussed openly (in fact, those discussions are encouraged). Software created in a Performance-oriented Culture will tend to have a Loosely Coupled architecture (due to Conway's Law ), with deployments that are fast (minutes) and frequent (on-demand, several times per-day), taking full advantage of a fully automated CI/CD pipeline. Changing the Culture \u00b6 The best way to change a culture is through an Inverse Conway Maneuver. Organize the teams and their communication channels to match the desired architecture. This will require cross-functional teams that adhere to Lean management, as well as a culture of Learning and Experimentation. Conway's Law: \"Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.\" Inverse Conway Maneuver: \"Make sure the organization is compatible with the product architecture.\" Learning and Experimentation \u00b6 Continuous learning Team must be free to choose their tools, and change those tools as their customer's problems are better understood. Tool makers can not force the use of their tool! Tools must make the developer's life easier. Just as a high-performing team focuses on solving the problems of their users, tool makers must treat other developers as their users and solve their problems (with attention to usability, accessibility, and customer satisfaction). Lean Management \u00b6 Adopt, Adapt, Adept Lightweight Change Management Limited WIP Visual Feedback (of production usage) Compare this to a bureaucratic Change Approval Board, which in practice results in Risk Management Theater, or InfoSec Theater, rather than actual risk-managements and security. The best visual feedback will tie small incremental changes to measures of customer satisfaction. For example, this could include user-engagement metrics, as well as feedback from advanced A/B testing (such as multi-armed-bandit algorithms). Refs \u00b6 https://www.youtube.com/watch?v=RJz1GlClG1M https://itrevolution.com/book/accelerate/ Westrum Model Inverse Conway Maneuver","title":"Good Teams"},{"location":"good-teams/#good-teams","text":"What is a Good software engineering team? How would you measure that? Notes from DevOps and Lean Software research. A good team will build quality products (services, platforms, etc) that solve real problems; and in order to be successful, a good team will require an inspiring vision, a Generative Culture, and the responsibility of fast / frequent deployments.","title":"Good Teams"},{"location":"good-teams/#the-vision","text":"A successful organization must have an inspiring vision; and it must be shared so as to unite the different teams and technologies within the organization. Without an inspiring (and shared) vision, an organization will inevitably fall into a default Bureaucratic Culture (a rule-oriented culture). In that environment software developers will adopt what is known as a mercenary mindset . What's worse, due to Conway's Law , these mercenary-minded developers will create technical output (products, services, platforms, etc) that reflect the bureaucratic communication channels between teams within the organization -- and they will NOT solve the problems of the users.","title":"The Vision"},{"location":"good-teams/#the-measures","text":"How would one measure a good team? Or more importantly, what can we easily measure that is a strong predictor for a high-performing software development team? It turns out, the following cluster of easy-to-measure metrics forms the best predictor of a high-performing team in a Generative Culture (a performance-oriented culture).","title":"The Measures"},{"location":"good-teams/#positive-measures","text":"Deployment Frequency -- how often do you deploy to production? Lead-Time -- from code-commit to production Mean-Time-To-Repair (MTTR) Change Failure Rate More usefully, the first three (as a cluster) predict the fourth measure . In other words, the most stable systems (with the lowest failure rates) are the systems that have fast and frequent deployments in a fully-automated CI/CD pipeline. A fully automated CI/CD pipeline is an essential and necesary part of building quality software, but as we'll see, there's much more to consider.","title":"Positive Measures"},{"location":"good-teams/#negavitve-measures","text":"In other words, what NOT TO DO ? This may defy conventional wisdom, but the following are negative-predictors towards quality software. In other words, they are not only highly correlated with bad software, the mere existence of the following will predict a higher failure rate, as well as increased security risks. Change Approval Board Velocity -- in the Agile/Scrum context Utilization -- \"as utilization approaches 100%, Lead-Time approaches infinity\"","title":"Negavitve Measures"},{"location":"good-teams/#meaningless-measures","text":"Surprisingly, the following common measures provide no correlation whatsover between high-performing teams and low-performing teams. These are not negatively correlated (and thus may still be important factors within your organization); but they simply do not correlate to the overall quality and stability of your software, and should not be used as comparative measures. Age of technology (mainframe vs distributed microservices) Size of the organization Whether Ops team or Dev team performs deployments Unit-test coverage Lines of code This isn't to say that the above items are themselves meaningless, far from it, but it's important to understand that these measures will not predict the quality and stability of your software. For example, there are teams ingrating with ancient mainframes (and no unit-tests) that are outperforming teams with a microservice architecture and 100% unit-test coverage. And while the size of an organization will not predict software quality, it is true that high-performing teams tend to scale much easier (scaling an organization requires a loosely coupled architecture more than anything else).","title":"Meaningless Measures"},{"location":"good-teams/#the-culture","text":"There are three categories of culture that one will find within software engineering organizations. Of these three, the Generative Culture (performance-oriented) is the one most likely produce quality software. For more information see Westrum Model of Organizational Culture Power-oriented Rule-oriented Performance-oriented Low cooperation Modest cooperation High cooperation Messengers \"shot\" Messengers neglected Messengers trained Responsibilities shirked Narrow responsibilities Risks are shared Bridging discouraged Bridging tolerated Bridging encouraged Failure leads to scapegoating Failure leads to justice Failure leads to inquiry Novelty crushed Novelty leads to problems Novelty implemented","title":"The Culture"},{"location":"good-teams/#power-oriented","text":"Also known as Pathological Culture , a Power-oriented Culture values individual goals over organizational goals, where the loudest and most powerful voice in the room gets their way. Communication does not flow easily, and problems are typically suppressed. Software created in a Power-oriented Culture will tend to have a Tightly Coupled architecture (due to Conway's Law ) and will reflect the particular whims of whoever has the most powerful voice (typically whoever is at the top of the hierarchy).","title":"Power-oriented"},{"location":"good-teams/#rule-oriented","text":"Also known as Bureaucratic Culture , a Rule-oriented Culture values departmental goals over organizational goals. This is the most common culture in software engineering organizations, and it is the default culture for most large organizations. While often friendly, information flow is stymied by bureaucratic approvals, and problems are typically ignored. Often times the emphasis is on being nice and well-liked, rather than building quality software (and making users happy). Software created in a Rule-oriented Culture will tend to have a Tightly Coupled architecture (due to Conway's Law ) and will reflect the particular bureaucratic communication channels between teams. There is likely a Change Approval Board, with deployments that are slower (measured in hours) and less-frequent (weekly or more) than what a fully automated CI/CD pipeline could otherwise provide.","title":"Rule-oriented"},{"location":"good-teams/#performance-oriented","text":"Also known as Generative Culture , a Performance-oriented Culture values the mission of the organization over all else. It is in this environment where developers adopt a missionary mindset (rather than the more common mercenary mindset). Information flows easily, problems and failures are discussed openly (in fact, those discussions are encouraged). Software created in a Performance-oriented Culture will tend to have a Loosely Coupled architecture (due to Conway's Law ), with deployments that are fast (minutes) and frequent (on-demand, several times per-day), taking full advantage of a fully automated CI/CD pipeline.","title":"Performance-oriented"},{"location":"good-teams/#changing-the-culture","text":"The best way to change a culture is through an Inverse Conway Maneuver. Organize the teams and their communication channels to match the desired architecture. This will require cross-functional teams that adhere to Lean management, as well as a culture of Learning and Experimentation. Conway's Law: \"Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure.\" Inverse Conway Maneuver: \"Make sure the organization is compatible with the product architecture.\"","title":"Changing the Culture"},{"location":"good-teams/#learning-and-experimentation","text":"Continuous learning Team must be free to choose their tools, and change those tools as their customer's problems are better understood. Tool makers can not force the use of their tool! Tools must make the developer's life easier. Just as a high-performing team focuses on solving the problems of their users, tool makers must treat other developers as their users and solve their problems (with attention to usability, accessibility, and customer satisfaction).","title":"Learning and Experimentation"},{"location":"good-teams/#lean-management","text":"Adopt, Adapt, Adept Lightweight Change Management Limited WIP Visual Feedback (of production usage) Compare this to a bureaucratic Change Approval Board, which in practice results in Risk Management Theater, or InfoSec Theater, rather than actual risk-managements and security. The best visual feedback will tie small incremental changes to measures of customer satisfaction. For example, this could include user-engagement metrics, as well as feedback from advanced A/B testing (such as multi-armed-bandit algorithms).","title":"Lean Management"},{"location":"good-teams/#refs","text":"https://www.youtube.com/watch?v=RJz1GlClG1M https://itrevolution.com/book/accelerate/ Westrum Model Inverse Conway Maneuver","title":"Refs"},{"location":"oops/","text":"End of OOP \u00b6 I would like to know when it is best to use object-oriented programming, and when it is best to use procedural programming. tl;dr: neither, go with functional programming By procedural programming, I mean the kind of code you'd find programming in C ; imperative control flow, functions, data structures, and algorithms. For example, #include <stdio.h> float f_to_c(float f) { return (f - 32) * 5 / 9; } int main() { float fahrenheit; printf(\"Please enter the temperature in Fahrenheit: \"); scanf(\"%f\", &fahrenheit); printf(\"Temperature in Celsius = %.2f\\n\", f_to_c(fahrenheit)); return 0; } And by object-oriented programming, I mean the kind of code with abstraction, inheritance, polymorphism, and encapsulation. For example, import java.util.*; interface TemperatureConverter { public float convert(); } class Temperature { float degrees; Temperature(float t) { degrees = t; } } class Fahrenheit extends Temperature implements TemperatureConverter { Fahrenheit(float t) { super(t); } public float convert() { return ((degrees - 32)*5)/9; } } class FahrenheitToCelsius { public static void main(String[] args) { Fahrenheit fahrenheit; Scanner in = new Scanner(System.in); System.out.print(\"Enter temperature in Fahrenheit: \"); fahrenheit = new Fahrenheit( in.nextFloat() ); System.out.println(\"temperature in Celsius = \" + fahrenheit.convert()); } } I admittedly forced some inheritance and polymorphism into the above code, but it's arguably just as easy (if not easier) to read than the C example (despite being considerably longer). In both cases we hid the implementation details (the specific formula that converts Fahrenheit to Celsius) from the main(). However, the OOP example also hides (encapsulates) the data structure as well. In the Java example we encapsulate the float within the Temperature base class, which the Fahrenheit class inherits. And since the Fahrenheit class implements the TemperatureConverter interface, then we're guaranteed to have a convert() method. There is still some implicit typecasting (a float to string within the println), but the idea is that the main() function doesn't care about the underlying data structure. As Robert Martin (Uncle Bob) put it, \"Objects expose behavior and hide data.\" The Fahrenheit class exposed a convert() behavior and hid the underlying data structure. This, according to Uncle Bob, makes it easy to add new objects without changing existing behaviors. For example, class Celsius extends Temperature implements TemperatureConverter { Celsius(float t) { super(t); } public float convert() { return 9*degrees/5 + 32; } } This code has no impact on the existing Fahrenheit class, and we can safely call convert() on both Fahrenheit and Celsius objects. Additionally, if we use generics on the Temperature class, then we could allow for different data structures (such as double or BigDecimal) on something like a Kelvin class. In OOP, adding new classes is generally easy. That said, what if we wanted to add new behavior? Maybe we want to add an isRoomTemperature() method. If so, we could add a new interface and then implement it in Celsius and Fahrenheit, but what if we had also implemented that new Kelvin class? Or several other Temperature classes? And shouldn't the convert() method return a Temperature class? This could get messy and will lead us into DRY problems. In fact, this is an area where OOP is not ideal. Even Uncle Bob admits that if we're adding new behaviors then \"we prefer data types and procedures.\" If we're adding new behavior then we prefer procedural code. This seemingly obvious and innocuous statement in Clean Code is actually very profound, especially considering the fact that OOP and classic procedural programming do not mix well in a single code-base. Whether you go with OOP or not, if Uncle Bob is correct, depends on whether or not you will be adding and managing lots of behavior, or whether you will be adding and managing lots of data types. If the behavior will be relatively unchanged, then OOP would be beneficial, but if we're planning to add or change behavior, then procedural programming would be preferred. I honestly don't know what kind of software projects aren't primarily adding new behaviors (new features). For reference, adding a room temperature check is easy in the C code, #include <stdio.h> #include <stdbool.h> bool is_c_room_temperature(float c) { return c >= 20 && c <= 25 ? 1 : 0; } float f_to_c(float f) { return (f - 32) * 5 / 9; } bool is_f_room_temperature(float f) { return is_c_room_temperature(f_to_c(f)); } int main() { float fahrenheit; printf(\"Please enter the temperature in Fahrenheit: \"); scanf(\"%f\", &fahrenheit); printf(\"Temperature in Celsius = %.2f\\n\", f_to_c(fahrenheit)); if (is_f_room_temperature(fahrenheit)) { printf(\"%.2f is room temperature\\n\", fahrenheit); } return 0; } Classic procedural code does not concern itself with adding behaviors to objects. Instead, it treats data types as data types and isolates the \"procedural\" behaviors into functions that are performed on those data types. If we stick to pure functions (no side effects, and all inputs map to unique outputs), then we'll have highly testable code that can run in highly-concurrent environments. For example, adding a Kelvin conversion would look like this, float c_to_k(float c) { return c + 273.15; } Likewise, adding a Fahrenheit to Kelvin conversion would simply chain together two pure functions, float f_to_k(float f) { return c_to_k(f_to_c(f)); } Procedural code focuses entirely on behavior. Adding this functionality in a pure OOP style would result a laundry list of classes, interfaces, and methods. It can get out of hand quickly, and we'd soon be researching design patterns to try to regain some sense of code quality. In practice, most developers tend to treat OOP and procedural programming with a sort of religious devotion, zealously adhering to their preferred programming style and feeling that the alternative is sacrilege. I think Uncle Bob was onto something when he said that \"good software developers understand these issues without prejudice and choose the approach that is best for the job at hand.\" That's also from Clean Code , a book that should be read at least as often as it's referenced (it's a bit like George Orwell's 1984, most people reference it without ever having read it). Uncle Bob is certainly more diplomatic than Joe Armstrong, the creator of Erlang, who had famously said, \"The problem with object-oriented languages is they\u2019ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.\" To date, I've never heard a reasonable counter-argument to this objection to OOP, namely, that objects bind data structures and functions together (which inevitably leads to an explosion of side-effects). Even as you try to decouple the banana from the gorilla, you end up creating even more classes, more side effects, and most likely an even worse problem . I'm not sure I'd go so far as to say OO Sucks , or that it's been an unmitigated disaster for software engineering, but I am hard pressed to defend OOP in light of decades of hard learned lessons . Obviously, good code is preferable to bad code in any language. There is plenty of bad procedural code out in the world. But honestly, in OOP you often find good programmers writing bad code. Let's go back to some of the earliest lessons in software engineering, specifically, Fred Brook's essay, No Silver Bullet , and ask ourselves how much accidental complexity has been created by OOP? How much code in an average OOP project is tackling the essential complexity of a problem versus the accidental complexity? In fairness, OOP was popularized by Java, which solved many problems from the early days of C and C++ (such as garbage collection and platform independence). In the decades since, Java has added capabilities found in modern languages (such as lambda expressions, collections, stream api, higher-order functions, etc). Most of the new capabilities come from the world of functional programming, and exactly zero of these capabilities come from OOP. Whether we like it or not, the future may not be kind to OOP. Multi-core architectures and distributed computing are pushing software into high-concurrency asynchronous environments. Even worse, the push to cloud computing and microservices leads us to an increase in latency within a highly concurrent asynchronous world. This is an ideal environment for a separation of data structures from functions (pure functions). This is a great environment for Haskell and Erlang (or coding pure functions using Scala, Python, or Go), but regardless of the language, you couldn't ask for a worse environment for OOP.","title":"End of OOP"},{"location":"oops/#end-of-oop","text":"I would like to know when it is best to use object-oriented programming, and when it is best to use procedural programming. tl;dr: neither, go with functional programming By procedural programming, I mean the kind of code you'd find programming in C ; imperative control flow, functions, data structures, and algorithms. For example, #include <stdio.h> float f_to_c(float f) { return (f - 32) * 5 / 9; } int main() { float fahrenheit; printf(\"Please enter the temperature in Fahrenheit: \"); scanf(\"%f\", &fahrenheit); printf(\"Temperature in Celsius = %.2f\\n\", f_to_c(fahrenheit)); return 0; } And by object-oriented programming, I mean the kind of code with abstraction, inheritance, polymorphism, and encapsulation. For example, import java.util.*; interface TemperatureConverter { public float convert(); } class Temperature { float degrees; Temperature(float t) { degrees = t; } } class Fahrenheit extends Temperature implements TemperatureConverter { Fahrenheit(float t) { super(t); } public float convert() { return ((degrees - 32)*5)/9; } } class FahrenheitToCelsius { public static void main(String[] args) { Fahrenheit fahrenheit; Scanner in = new Scanner(System.in); System.out.print(\"Enter temperature in Fahrenheit: \"); fahrenheit = new Fahrenheit( in.nextFloat() ); System.out.println(\"temperature in Celsius = \" + fahrenheit.convert()); } } I admittedly forced some inheritance and polymorphism into the above code, but it's arguably just as easy (if not easier) to read than the C example (despite being considerably longer). In both cases we hid the implementation details (the specific formula that converts Fahrenheit to Celsius) from the main(). However, the OOP example also hides (encapsulates) the data structure as well. In the Java example we encapsulate the float within the Temperature base class, which the Fahrenheit class inherits. And since the Fahrenheit class implements the TemperatureConverter interface, then we're guaranteed to have a convert() method. There is still some implicit typecasting (a float to string within the println), but the idea is that the main() function doesn't care about the underlying data structure. As Robert Martin (Uncle Bob) put it, \"Objects expose behavior and hide data.\" The Fahrenheit class exposed a convert() behavior and hid the underlying data structure. This, according to Uncle Bob, makes it easy to add new objects without changing existing behaviors. For example, class Celsius extends Temperature implements TemperatureConverter { Celsius(float t) { super(t); } public float convert() { return 9*degrees/5 + 32; } } This code has no impact on the existing Fahrenheit class, and we can safely call convert() on both Fahrenheit and Celsius objects. Additionally, if we use generics on the Temperature class, then we could allow for different data structures (such as double or BigDecimal) on something like a Kelvin class. In OOP, adding new classes is generally easy. That said, what if we wanted to add new behavior? Maybe we want to add an isRoomTemperature() method. If so, we could add a new interface and then implement it in Celsius and Fahrenheit, but what if we had also implemented that new Kelvin class? Or several other Temperature classes? And shouldn't the convert() method return a Temperature class? This could get messy and will lead us into DRY problems. In fact, this is an area where OOP is not ideal. Even Uncle Bob admits that if we're adding new behaviors then \"we prefer data types and procedures.\" If we're adding new behavior then we prefer procedural code. This seemingly obvious and innocuous statement in Clean Code is actually very profound, especially considering the fact that OOP and classic procedural programming do not mix well in a single code-base. Whether you go with OOP or not, if Uncle Bob is correct, depends on whether or not you will be adding and managing lots of behavior, or whether you will be adding and managing lots of data types. If the behavior will be relatively unchanged, then OOP would be beneficial, but if we're planning to add or change behavior, then procedural programming would be preferred. I honestly don't know what kind of software projects aren't primarily adding new behaviors (new features). For reference, adding a room temperature check is easy in the C code, #include <stdio.h> #include <stdbool.h> bool is_c_room_temperature(float c) { return c >= 20 && c <= 25 ? 1 : 0; } float f_to_c(float f) { return (f - 32) * 5 / 9; } bool is_f_room_temperature(float f) { return is_c_room_temperature(f_to_c(f)); } int main() { float fahrenheit; printf(\"Please enter the temperature in Fahrenheit: \"); scanf(\"%f\", &fahrenheit); printf(\"Temperature in Celsius = %.2f\\n\", f_to_c(fahrenheit)); if (is_f_room_temperature(fahrenheit)) { printf(\"%.2f is room temperature\\n\", fahrenheit); } return 0; } Classic procedural code does not concern itself with adding behaviors to objects. Instead, it treats data types as data types and isolates the \"procedural\" behaviors into functions that are performed on those data types. If we stick to pure functions (no side effects, and all inputs map to unique outputs), then we'll have highly testable code that can run in highly-concurrent environments. For example, adding a Kelvin conversion would look like this, float c_to_k(float c) { return c + 273.15; } Likewise, adding a Fahrenheit to Kelvin conversion would simply chain together two pure functions, float f_to_k(float f) { return c_to_k(f_to_c(f)); } Procedural code focuses entirely on behavior. Adding this functionality in a pure OOP style would result a laundry list of classes, interfaces, and methods. It can get out of hand quickly, and we'd soon be researching design patterns to try to regain some sense of code quality. In practice, most developers tend to treat OOP and procedural programming with a sort of religious devotion, zealously adhering to their preferred programming style and feeling that the alternative is sacrilege. I think Uncle Bob was onto something when he said that \"good software developers understand these issues without prejudice and choose the approach that is best for the job at hand.\" That's also from Clean Code , a book that should be read at least as often as it's referenced (it's a bit like George Orwell's 1984, most people reference it without ever having read it). Uncle Bob is certainly more diplomatic than Joe Armstrong, the creator of Erlang, who had famously said, \"The problem with object-oriented languages is they\u2019ve got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.\" To date, I've never heard a reasonable counter-argument to this objection to OOP, namely, that objects bind data structures and functions together (which inevitably leads to an explosion of side-effects). Even as you try to decouple the banana from the gorilla, you end up creating even more classes, more side effects, and most likely an even worse problem . I'm not sure I'd go so far as to say OO Sucks , or that it's been an unmitigated disaster for software engineering, but I am hard pressed to defend OOP in light of decades of hard learned lessons . Obviously, good code is preferable to bad code in any language. There is plenty of bad procedural code out in the world. But honestly, in OOP you often find good programmers writing bad code. Let's go back to some of the earliest lessons in software engineering, specifically, Fred Brook's essay, No Silver Bullet , and ask ourselves how much accidental complexity has been created by OOP? How much code in an average OOP project is tackling the essential complexity of a problem versus the accidental complexity? In fairness, OOP was popularized by Java, which solved many problems from the early days of C and C++ (such as garbage collection and platform independence). In the decades since, Java has added capabilities found in modern languages (such as lambda expressions, collections, stream api, higher-order functions, etc). Most of the new capabilities come from the world of functional programming, and exactly zero of these capabilities come from OOP. Whether we like it or not, the future may not be kind to OOP. Multi-core architectures and distributed computing are pushing software into high-concurrency asynchronous environments. Even worse, the push to cloud computing and microservices leads us to an increase in latency within a highly concurrent asynchronous world. This is an ideal environment for a separation of data structures from functions (pure functions). This is a great environment for Haskell and Erlang (or coding pure functions using Scala, Python, or Go), but regardless of the language, you couldn't ask for a worse environment for OOP.","title":"End of OOP"},{"location":"pair-programming/","text":"Pair Programming \u00b6 On Pair Programming","title":"Pair Programming"},{"location":"pair-programming/#pair-programming","text":"On Pair Programming","title":"Pair Programming"}]}